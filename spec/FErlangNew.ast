/*  Abstract syntax for two buyer in erlang */

Program ::= Modules:Module*;
Module::= <Partecipant:String> <RegisteredName:String> <ModuleName:String> <FunName:String> Functions:Function*;

Function ::= <FunType:String> <FunctionName:String> Parameters:Variable* Body:Process;

abstract Term;

Message:Term ::= Sender:SenderId Label:Atom Payload:Expression*;

ReceiveClause:Term ::= Sender:Atom Label:Atom Variables:Pattern* Actions:Process;
CaseClause:Term ::= Patterns:Pattern* Actions:Process;

abstract Process:Term;
Send:Process ::= Recipient:Atom Message:Message [Next:Process];
Receive:Process ::= Clauses:ReceiveClause* [Next:Process];
Case:Process ::= Matching:Expression* Clauses:CaseClause* [Next:Process];
Let:Process ::= Left:Variable Right:Expression Next:Process;
ExpressionProcess:Process ::= Expression:Expression [Next:Process];

/*  expressions  */
abstract Expression:Term;
Operator:Expression ::= <OperatorSymbol:String> LeftOp:Expression RightOp:Expression;
Call:Expression ::= FunctionName:Atom Arguments:Expression*;
Self:Expression;


/*  literals  */
abstract Pattern:Expression;
abstract Literal:Pattern;
Atom:Literal ::= <Ident:String>;
Pid:Literal::= <Pid:String>;
CharList:Literal ::= <StringValue:String>;
Number:Literal ::= <IntegerValue:Integer>;
Boolean:Literal ::= <BooleanValue:boolean>;

Variable:Pattern::= <Ident:String>;

SenderId:Term;
AtomSender:SenderId ::= <Ident:String>;
VarSender:SenderId ::= <Ident:String>;

abstract Session:Term;
SessionLiteral:Session ::= Literal:Literal;
SessionSend:Session ::= Sender:Atom Label:Atom <Type:String> Next:Session;
InternalChoice:Session ::= Sends:SessionSend*;
ExternalChoice:Session ::= Receives:SessionReceive*;
RequestForwardDelegation ::= Delegating:Atom Next:Session;
RequestBackwardDelegation ::= Delegating:Atom Next:Session;
AcceptForwardDelegation ::= Delegate:Atom Next:Session;
AcceptBackwardDelegation ::= Delegate:Atom Next:Session;

SessionReceive:Term ::= Recipient:Atom Label:Atom <Type:String> Next:Session;




