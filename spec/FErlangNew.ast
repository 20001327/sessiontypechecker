/*  Abstract syntax for two buyer in erlang */

abstract Goal;
Program:Goal ::= Modules:Module*;

Module::= <Partecipant:String> <RegisteredName:String> <ModuleName:String> <FunName:String> Functions:Function*;

Function ::= [Type:FunType] <FunctionName:String> Parameters:Variable* Body:Process;  /* funType di tipo funType */
Anno ::= <Line:Integer> <StartToken:Integer>;
Message ::= Sender:SenderId Label:Atom Payload:Expression*;

ReceiveClause ::= Sender:Atom Label:Atom Variables:Pattern* Actions:Process;
CaseClause ::= Patterns:Pattern* Actions:Process;

abstract Process;
Send:Process ::= Recipient:Atom Message:Message Next:Process;
Register:Process ::= Arguments:Expression* Next:Process;
Unregister:Process ::= Arguments:Expression* Next:Process;
Receive:Process ::= Clauses:ReceiveClause* [Next:Process];
Case:Process ::= Matching:Expression* Clauses:CaseClause* [Next:Process];
Let:Process ::= Left:Variable Right:Expression Next:Process;
ExpressionProcess:Process ::= Expression:Expression;

/*  expressions  */
abstract Expression;
Operator:Expression ::= <OperatorSymbol:String> LeftOp:Expression RightOp:Expression;
Call:Expression ::= FunctionName:Atom Arguments:Expression*;
Self:Expression;


/*  literals  */
abstract Pattern:Expression;
abstract Literal:Pattern;
Atom:Literal ::= <Ident:String>;
Pid:Literal::= <Pid:String>;
CharList:Literal ::= <StringValue:String>;
Number:Literal ::= <IntegerValue:Integer>;
Boolean:Literal ::= <BooleanValue:boolean>;

Variable:Pattern::= <Ident:String>;

SenderId;
AtomSender:SenderId ::= <Ident:String>;
VarSender:SenderId ::= <Ident:String>;

abstract Session;
SessionSend:Session ::= Sender:Atom Label:Atom Type:LiteralType* Next:Session;
SessionReceive:Session ::= Recipient:Atom Label:Atom Type:LiteralType* Next:Session;
InternalChoice:Session ::= Sends:SessionSend*;
ExternalChoice:Session ::= Receives:SessionReceive*;
RequestForwardDelegation:Session ::= Delegating:Atom Next:Session;
RequestBackwardDelegation:Session ::= Delegating:Atom Next:Session;
AcceptForwardDelegation:Session ::= Delegate:Atom Next:Session;
AcceptBackwardDelegation:Session ::= Delegate:Atom Next:Session;
End:Session;

abstract LiteralType:Session;
AtomType:LiteralType;
IntType:LiteralType;
StringType:LiteralType;
PidType:LiteralType;
BoolType:LiteralType;
ActorPid:LiteralType::=<Actor:String>;
AtS:LiteralType::=<Partecipant:String>;

FunType:Session ::= <FunName:String> Arguments:LiteralType* SessionType:Session;


FunctionType ::= <FunName:String> Arguments:LiteralType* SessionType:Session;



