/*  Abstract syntax for two buyer in erlang */

Program ::= Modules:Module*;
Module::= <Partecipant:String> Functions:Function*;
/* start - function come secondo argomento */

Type ::= <Type:String>;
Function ::= <FunctionName:String> <ArgumentsNumber:Integer> Clauses:Clause*;

abstract Term:

abstract Process:Term;                                    // Process
Send:Process ::= Recipient:Atom Message:Message;
Receive:Process ::= Patterns:ReceiveClause*;
Case:Process ::= MatchingForm:Expression* Patterns:Clause*;
Let:Process ::= LeftForm:Variable RightForm:Expression;

Register:Production ::= Name:Atom MyPid:Pid;
Unregister:Production ::= Name:Atom;

Clause::= PatternVar:Pattern* /* GuardValues:Let* */ Forms:Production*;
ReceiveClause::= PatternVar:Pattern* GuardValues:Let* Forms:Production*;// sender:atom label:atom payload:variables
//receive pattern
//case pattern
//function pattern

/*  expressions  */
abstract Expression:Term;
Pattern:Expression;
Operator:Expression ::= <OperatorSymbol:String> LeftOp:Expression RightOp:Expression;
Call:Expression ::= FunctionName:Atom Arguments:Expression*;
Self:Expression;


/*  litterals  */
Message:Pattern ::= Sender:Identifier Label:Atom Payload:Expression*;
abstract Litteral:Pattern;
Pid:Litteral::= <Pid:String>;
CharList:Litteral ::= <StringValue:String>;
Number:Litteral ::= <IntegerValue:Integer>;
Boolean:Litteral ::= <BooleanValue:Boolean>;

abstract Identifier:Pattern;
Variable:Identifier::= <Ident:String>;
Atom:Identifier::= <AtomValue:String>;
