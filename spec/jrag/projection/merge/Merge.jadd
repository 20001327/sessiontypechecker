

aspect Merge{

    public static List<SessionReceive> Session.merge(List<Session> sessions){
        List<SessionReceive> ret = new List();
        List<Session> recs = new List();
        boolean allSimple = true;
        boolean allConnecting = true;

        Map<String, String> map = new HashMap();

        for(int i = 0; i<sessions.getNumChild();i++){
              if(sessions.getChild(i).isSubtypeOf(new ExternalChoice())){
                  ExternalChoice ext = (ExternalChoice)sessions.getChild(i);
                  for(SessionReceive r: ext.getReceivess()){
                    if(!r.isReceivePresentInThisMap(map)) recs.add(r);
                  }
              }else if(sessions.getChild(i).isSubtypeOf(new SessionReceive())){
                  SessionReceive r = (SessionReceive)sessions.getChild(i);
                  if(!r.isReceivePresentInThisMap(map)) recs.add(r);
              }
        }

        for(int i = 0; i<recs.getNumChild();i++){
            allSimple = allSimple && Program.sameClass(recs.getChild(i),SessionReceive.class);
            allConnecting = allConnecting && (Program.sameClass(recs.getChild(i),ConnectingReceive.class)
                                        || recs.getChild(i).isSubtypeOf(new End()));
        }

        if(allConnecting || allSimple){

            for(int i = 0; i<recs.getNumChild();i++){
                boolean add = true;
                SessionReceive toBeAdded = (SessionReceive)recs.getChild(i);
                for(int j=0; j<ret.getNumChild();j++){
                    SessionReceive present = (SessionReceive)ret.getChild(j);
                    add = add && !present.equals(toBeAdded);
                }

                if(add){
                    ret.add(toBeAdded);
                }
            }

            return ret;
        }

        return null;
    }

}