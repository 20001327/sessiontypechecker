import java.util.HashMap;
import java.util.Map;

aspect TypeAnalysis {

    public class TypeInfo {

        List<Module> moduleList = new List();
        String moduleName;
        Atom delegating;

        public void setModuleName(String name){
            moduleName = name;
        }

        public String getModuleName(){
            return moduleName;
        }

        public void setModuleList(List<Module> list){
            moduleList = list;
        }

        public List<Module> getModuleList(){
            return moduleList;
        }

        public void setDelegating(Atom del){
            delegating = del;
        }

        public Atom getDelegating(){
            return delegating;
        }

        public Process getNext(Process p){
            String className = p.getClass().getName();
            if(className.equals(ExpressionProcess.class.getName())){
                ExpressionProcess exp = (ExpressionProcess) p;
                if(exp.hasNext()){
                    return exp.getNext();
                }
            }else if(className.equals(Send.class.getName())){
                Send exp = (Send) p;
                if(exp.hasNext()){
                    return exp.getNext();
                }
            }

            return null;
        }

        public Send searchSendInMod(String moduleName,String dest, String label){
            for (Module module: moduleList){
                if(module.getPartecipant().equals(moduleName)){
                    for(Function f: module.getFunctionss()){
                        return searchSend(f.getBody(), dest, label);
                    }
                }
            }
            return null;
        }


        public Send searchSend(Process process, String dest, String label){
            String className = process.getClass().getName();
            if(className.equals(Send.class.getName())){
                Send s = (Send) process;
                if(s.getRecipient().getIdent().equals(dest)
                    && s.getMessage().getLabel().getIdent().equals(label)){
                    return s;
                }else if(s.hasNext()) {
                    return searchSend(s.getNext(),dest,label);
                }
            }else if(className.equals(Receive.class.getName())){
                Receive s = (Receive) process;
                Send send = null;
                for (ReceiveClause rc : s.getClausess()){
                    send = searchSend(rc.getActions(),dest,label);
                    if (send!=null) return send;
                }
                if(s.hasNext()) return searchSend(s.getNext(),dest,label);
            }else if(className.equals(Case.class.getName())){
                Case s = (Case) process;
                Send send = null;
                for (CaseClause rc : s.getClausess()){
                    send = searchSend(rc.getActions(),dest,label);
                    if (send!=null) return send;
                }
                if(s.hasNext()) return searchSend(s.getNext(),dest,label);
            }else if(className.equals(Let.class.getName())){
                Let s = (Let) process;
                return searchSend(s.getNext(),dest,label);
            }else if(className.equals(ExpressionProcess.class.getName())){
                ExpressionProcess s = (ExpressionProcess) process;
                if(s.hasNext()) return searchSend(s.getNext(),dest,label);
            }

            return null;
        }

        public boolean checkUnregister(List<Process> processes, Expression e){
            boolean found = false;
            for(Process p:processes){
                if(!found && p.getClass().getName().equals(ExpressionProcess.class.getName())){
                    Expression call = ((ExpressionProcess) p).getExpression();
                    if(call.getClass().getName().equals(Call.class.getName())){
                        Call c = (Call) call;
                        found = c.getArguments(0).equals(e);
                    }
                }
            }
            return found;
        }

    }

    syn lazy TypeInfo Function.typeInfo() {
       return new TypeInfo();
    }

    eq Function.getBody().typeInfo() = this.typeInfo();

    inh lazy TypeInfo FunType.typeInfo();
    inh lazy TypeInfo Process.typeInfo();
    inh lazy TypeInfo Expression.typeInfo();
    inh lazy TypeInfo Session.typeInfo();
    inh lazy TypeInfo Message.typeInfo();
    inh lazy TypeInfo ReceiveClause.typeInfo();
    inh lazy TypeInfo CaseClause.typeInfo();
    inh lazy TypeInfo SenderId.typeInfo();


    // get fun type inheriting
    eq Function.getBody().getFunType() = this.getType();

    inh lazy FunType Process.getFunType();
    inh lazy FunType Expression.getFunType();


    // visita nel session type annotato per trovare i tipi di una send
    eq Function.getBody().getInfo(String label, int index) = this.getInfo(label,index);
    inh lazy Session Process.getInfo(String label,int index);
    inh lazy Session ReceiveClause.getInfo(String label,int index);

    syn lazy Session Function.getInfo(String label,int index){
        return getType().getSessionType().getInfo(label, index);
    }



}
