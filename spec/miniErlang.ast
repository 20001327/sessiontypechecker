/*  Abstract syntax for two buyer in erlang */

Program ::= Modules:Module*;
Module::= Functions:Function*;

abstract Form ::= <FormType:String> <RowNumber:Integer>;

/* ancora da sistemare
Function:Form ::= <FunctionName:String> <ArgumentsNumber:int> Arguments:Form*;
Receive:Form ::= Patterns:Clause*;
Case ::= MatchingForm:Form Patterns:Clause*;
If:Form ::= FirstClause:Clause SecondClause:Clause;
Call:Form ::= Method:MethodForm Arguments:Form*;
Match:Form ::= LeftForm:Form RightForm:Form;
Var:Form ::= <VarName:String> [VarValue:Form];
Operator:Form ::= <OperatorSymbol:String> <LeftOp:Value> <RightOp:Value>;
Cons:Form ::= Head:Form [Tail:Form];

MethodForm:Form ::= [Library:Atom] FunctionName:Atom;
*/

abstract Clause:Form;
Pattern:Form::= PatternVar:Variable* [GuardValues:Value*];
Guard:Form::= PatternVar:Variable* GuardValues:Value*;

Message:Form;

Record:Message ::= RecordName:Id Fields:RecordField*;
Tuple:Message ::= Fields:Value*;

RecordField:Form ::= RecordName:Atom RecordValue:Value;

abstract Value;
Identifier:Value::= <Identif:Id>;
Atom:Value::= <FormType:String> <RowNumber:Integer> <AtomValue:String>;
StringForm:Value ::= <FormType:String> <RowNumber:Integer> <StringValue:String>;
Nil:Value;

abstract Ident;
Variable:Ident::= <Id:String>;
Pid:Ident::= <Pid:Integer>




