%header {:
	/* This code is inlined before the generated parser */
	package miniErlang;
:};

%embed {:
	/* This code is inlined in the generated parser class */
:};

/* Just to shut up Beaver warnings */
%goal goal;
%left RBRACKET;
/* Productions with semantic actions building the JastAdd AST */

program goal =
	module_list 	    	    {: return new Program(module_list); :}
;

Module module =  /* Ci mettiamo dentro anche la start */
    LBRACKET actor COMMA
        LCURLYBRACE FUNCTION COMMA INTEGER.rowNumber
            COMMA START COMMA INTEGER.numArguments COMMA LBRACKET clause_list.patterns RBRACKET
        RCURLYBRACE COMMA
    function_list
    RBRACKET
    {: return new Module(actor.getActorName(), function_list); :}
;

Actor actor =
   LCURLYBRACE ATTRIBUTE COMMA INTEGER.rowNumber COMMA MODULE COMMA IDENTIFIER.value RCURLYBRACE
   {: return new Actor(value); :}
;

List module_list =
    module                  {: return new List().add(module); :}
|   module_list COMMA module      {: return module_list.add(module); :}
;

List function_list =
	function		        {: return new List().add(function);	:}
|	function_list COMMA function	{: return function_list.add(function); :}
;

Function function =
type? LCURLYBRACE FUNCTION COMMA INTEGER.rowNumber COMMA IDENTIFIER.funName COMMA
INTEGER.numArguments COMMA LBRACKET clause_list.patterns RBRACKET RCURLYBRACE
     {: return new Function(funName, Integer.parseInt(numArguments), patterns); :}
;

Type type =
   LCURLYBRACE ATTRIBUTE COMMA INTEGER.rowNumber COMMA TYPE COMMA LCURLYBRACE IDENTIFIER.funName COMMA atom COMMA LBRACKET RBRACKET RCURLYBRACE RCURLYBRACE COMMA
   {: return new Type(atom.getAtomValue()); :}
 ;

Clause clause =
    LCURLYBRACE CLAUSE COMMA INTEGER.rowNumber COMMA
    LBRACKET pattern_list.patterns RBRACKET COMMA
    LBRACKET let_list.matches? RBRACKET COMMA
    LBRACKET production_list RBRACKET RCURLYBRACE
       {: return new Clause(patterns, matches, production_list); :}
;

List clause_list =
	clause   		        {: return new List().add(clause);	:}
|	clause_list COMMA clause    	{: return clause_list.add(clause); :}
 ;

Production production =
   LCURLYBRACE OPERATOR COMMA INTEGER.rowNumber COMMA SINGLEMARKS SEND SINGLEMARKS COMMA
        atom.dest COMMA message.message RCURLYBRACE
        {: return new Send(dest, message); :}
|	LCURLYBRACE RECEIVE COMMA INTEGER.rowNumber COMMA LBRACKET clause_list.clauses RBRACKET RCURLYBRACE
 		{: return new Receive(clauses); :}
|   LCURLYBRACE CASE COMMA INTEGER.rowNumber COMMA
    Expression.matchingForm COMMA
    LBRACKET clause_list.clauses RBRACKET RCURLYBRACE
        {: return new Case(matchingForm, clauses); :}
|   let
;


Let let = LCURLYBRACE MATCH COMMA INTEGER.rowNumber COMMA variable.left
            COMMA expression.right RCURLYBRACE
        {: return new Let(left, right); :}
;

List let_list =
	let   		        {: return new List().add(let);	:}
|	let_list COMMA let    	{: return let_list.add(let); :}
 ;


List production_list =
    production                    {: return new List().add(production);     :}
|   production_list COMMA production          {: return production_list.add(production);      :}
;

Expression expression =
   litteral
|  variable
| LCURLYBRACE OPERATOR COMMA INTEGER.rowNumber COMMA SINGLEMARKS SYMBOL.sym SINGLEMARKS COMMA
    expression.op1 COMMA expression.op2 RCURLYBRACE
    {: return new Operator(sym,op1, op2); :}
|   LCURLYBRACE CALL COMMA INTEGER.rowNumber COMMA atom.method COMMA LBRACKET expression_list.arguments RBRACKET RCURLYBRACE
       {: return new Call(method, arguments); :}
|   LCURLYBRACE CALL COMMA INTEGER.rowNumber COMMA
    LCURLYBRACE ATOM COMMA INTEGER.rowNumber_ COMMA SELF RCURLYBRACE
    COMMA LBRACKET RBRACKET RCURLYBRACE
       {: return new Self(); :}

;

List expression_list =
	expression   		                    {: return new List().add(expression);	:}
|	expression_list COMMA expression    	{: return let_list.add(expression); :}
 ;

Pattern pattern =
    message
|   litteral
|   variable
;


List pattern_list =
	pattern   		                {: return new List().add(pattern);	:}
|	pattern_list COMMA pattern    	{: return let_list.add(pattern); :}
 ;

Message message =
 LCURLYBRACE TUPLE COMMA INTEGER.rowNumber COMMA LBRACKET identifier.id COMMA
  atom.recipient COMMA expression_list RBRACKET RCURLYBRACE
        {: return new Message(id,recipient,expression_list); :}
;

Litteral litteral =
    atom
|   pid
|   number
|   charlist
;

Identifier identifier =
|   variable
|   atom
;

Number number =
    LCURLYBRACE INTTYPE COMMA INTEGER.rowNumber COMMA INTEGER.val RCURLYBRACE
    {: return new Number(Integer.parseInt(val)); :}
;

CharList charlist = LCURLYBRACE STRING COMMA INTEGER.rowNumber COMMA STRINGVALUE RCURLYBRACE
      {: return new CharList(STRINGVALUE); :}
;

Atom atom =
LCURLYBRACE ATOM COMMA INTEGER.rowNumber COMMA IDENTIFIER.i RCURLYBRACE
        {: return new Atom(i); :}
|LCURLYBRACE ATOM COMMA INTEGER.rowNumber COMMA ATOMID RCURLYBRACE
        {: return new Atom(ATOMID); :}
;

Pid pid = PID.mypid
     {: return new Pid(mypid); :}
;

Variable variable =
    LCURLYBRACE VAR COMMA INTEGER.rowNumber COMMA VARIABLEID RCURLYBRACE
    {: return new Variable(VARIABLEID); :}
;
